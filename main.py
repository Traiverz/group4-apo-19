#хххххххххххххххххххххххххххххх ИМПОРТИРОВАНИЕ БИБЛИОТЕК хххххххххххххххххххххххххххххх
import time
import turtle
import border
import smile
import zmeyka
import ball
from random import randrange
#хххххххххххххххххххххххххххххх СОЗДАНИЕ ОКНА ПРОГРАММЫ хххххххххххххххххххххххххххххх
screen = turtle.Screen() # создал окно программы
screen.title('Змейка')  # задал название окна
screen.bgcolor('gold')  # задал цвет фона
screen.setup(650, 700) # задал размер окна
screen.tracer(0) # отключил анимацию рисования
#хххххххххххххххххххххххххххххх СОЗДАНИЕ НЕОБХОДИМЫХ ПЕРЕМЕННЫХ хххххххххххххххххххххххххххххх
bord = border.Border(311, 311) # создал игровые поля
smile = smile.Trey() # создал переменную класса смайл
snake = zmeyka.zmeyka() # создал переменную класса змейка
cherepaha = ball.cherepaha(-300, 0) # создал переменную класса мяч
#хххххххххххххххххххххххххххххх СОЗДАНИЕ ПЕРВОГО ТИПА ЕДЫ хххххххххххххххххххххххххххххх
ball1 = turtle.Turtle() # создал объект класса туртл
ball1.shape('circle') # дал ему форму шара
ball1.color('blue') # цвет выбрал синий
ball1.penup() # поднял карандаш
dx = randrange(0, 10) # новая переменная которая будет определять перемещение шарика по оси Х
dy = randrange(0, 10) # новая переменная которая будет определять перемещение шарика по оси У
randx = randrange(-300, 300) # номая переменная определяющая положение на поле по Х
randy = randrange(-300, 300) # новая переменная определяющая положение на поле по оси У
ball1.goto(randx, randy) # перемещаем мяч в новые координаты
#хххххххххххххххххххххххххххххх СОЗДАНИЕ ВТОРОГО ТИПА ЕДЫ хххххххххххххххххххххххххххххх
food = turtle.Turtle() # создаем объект еды
food.shape('circle') # задаем форму шара
food.penup() # поднял карандаш
food.goto(randrange(-300, 300), randrange(-300, 300)) # переместил в случайные координаты

screen.onkeypress(lambda: snake.snake[0].setheading(90), 'Up') # обработка события, по нажатию клавиш с клавиатуры для змейки (вверх)
screen.onkeypress(lambda: snake.snake[0].setheading(270), 'Down') # обработка события, по нажатию клавиш с клавиатуры для змейки (вниз)
screen.onkeypress(lambda: snake.snake[0].setheading(180), 'Left') # обработка события по нажатию клавиш с клавиатуры для змейки (влево)
screen.onkeypress(lambda: snake.snake[0].setheading(0), 'Right') # обработка события по нажатию клавиш с клавиатуры для змейки (вправо)
screen.listen() # считывание нажатия на клавишу

k = -300 # переменная которая будет использоваться для перемещения объекта по формуле в теле программы
score = 0 # переменная определяющая рекорд игры

while True: # бесконечный массив с обработкой случаев выхода из него
    x, y = ball1.position()  # координаты позиции летающей еды
    if x + dx >= 295 or x + dx <= -295:  # обработка отскока
        dx = -dx  # переворачиваем прирост в обратное направление
    if y + dy >= 295 or y + dy <= -295:  # так же только по координате У
        dy = -dy  #
    ball1.goto(x + dx, y + dy)  # перемещение летающей еды

    # движение тела змеи
    for i in range(len(snake.snake) - 1, 0, -1):  # перебираем все элементы змейки
        x = snake.snake[i - 1].xcor()  # определяем новую координату Х
        y = snake.snake[i - 1].ycor()  # определяем новую координату У
        snake.snake[i].goto(x, y)  # двигаем на новую координату

    # обработка движения головы змеи
    snake.snake[0].forward(20)  # голова змеи двигается на 20 пикс
    screen.update()  # обновляем экран

    # обработка положения головы змеи относительно краёв карты
    x_cor = snake.snake[0].xcor()  # переменная с координатой Х головы змеи
    y_cor = snake.snake[0].ycor()  # переменная с координатой У головы змеи
    if x_cor > 300 or x_cor < -300:  # если уходит за края карты
        smile.lose(1, 40, 55, 80, 95, 120, 180, 100) # активируем метот класса отвечающий за проигрыш
        snake.die(screen, score) # активируем метод класса отвечающий за смерть
        break # выход из цикла
    if y_cor > 300 or y_cor < -300:  # если уходит за края карты
        snake.die(screen, score) # активируем метод класса отвечающий за смерть
        smile.lose(1, 40, 55, 80, 95, 120, 180, 100) # активируем метот класса отвечающий за проигрыш
        break # выход из цикла

    # обработка поедания змеёй еды
    if snake.snake[0].distance(food) < 15: # если расстояние от головы до простой еды меньше 20:
        food.goto(randrange(-300, 300), randrange(-300, 300)) # еда переходит в новое место
        snake.eat(1, score) # активируется метод поедания еды
        score = score + 1 # добавляем одно очко в результат

    if snake.snake[0].distance(ball1) < 15: # если расстояние от головы до летающей еды меньше 20:
        ball1.goto(randrange(-300, 300), randrange(-300, 300))  # еда переходит в новое место
        snake.eat(3, score) # активируется метод поедания еды
        score = score + 3 # добавляем три очка в результат

    # вернёмся к свободной черепашке и задаю ее движение
    cherepaha.pos(k) # перемещение свободный черепашки
    if k >= 300: # условие если уходит за край карты
        k = -300 # перемещаем назад
    k = k + 5 # если не прошла условие двигаем вправо
    cherepaha.dvig(screen) # метод движения

    time.sleep(0.1) # остановка времени работы программы (так можно настроить сложность игры)

# если произошёл выход из цикла, надо чтобы окно не закрывалось сразу же
screen.mainloop() # застывание окна
